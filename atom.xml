<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Samson&#39;s Blog</title>
  
  <subtitle>记录工作、生活的点点滴滴...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://samson-bu.github.io/"/>
  <updated>2018-11-30T06:03:37.761Z</updated>
  <id>https://samson-bu.github.io/</id>
  
  <author>
    <name>Samson Bu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器加载、渲染HTML的流程</title>
    <link href="https://samson-bu.github.io/2018/11/26/browser-loading-process.html"/>
    <id>https://samson-bu.github.io/2018/11/26/browser-loading-process.html</id>
    <published>2018-11-26T02:37:30.000Z</published>
    <updated>2018-11-30T06:03:37.761Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><a href="https://blog.csdn.net/liupeifeng3514/article/details/78998293" target="_blank" rel="noopener">浏览器中 Javascript 的加载原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liupeif
      
    
    </summary>
    
    
      <category term="nodejs" scheme="https://samson-bu.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程和锁</title>
    <link href="https://samson-bu.github.io/2018/11/16/java-multi-thread.html"/>
    <id>https://samson-bu.github.io/2018/11/16/java-multi-thread.html</id>
    <published>2018-11-16T07:44:02.000Z</published>
    <updated>2018-11-30T05:48:19.247Z</updated>
    
    <content type="html"><![CDATA[<p>JVM支持多个线程的同时执行，它们独立地执行代码，操作保存在共享主存中的值和对象。多线程支持可以通过多个硬件处理器、单处理分时以及多处理器分时来实现。用户创建线程的唯一途径是实例化一个<code>Thread</code>类的对象，并通过<code>start()</code>方法来激活线程。如果未能正确的同步多线程，则它们的行为将可能是令人迷惑的，甚至是反直觉的。本章将介绍Java多线程程序的语义，它包含关于哪些变量是可见的（通过读被多个线程更新的共享内存）规则。<br>因为此规范类似于不同硬件体系结构的内存模型，语义也被称为是<em>Java编程语言内存模型</em>。语义并没有规定一个多线程程序是如何执行的，而是描述了该程序被允许出现的行为。一个只会残生被允许行为的执行策略是一个可接受的执行策略。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#synchronization">同步</a></li><li><a href="#wsan">等待集和通知</a></li><li><a href="#say">Sleep和Yield</a></li><li><a href="#mm">内存模型</a></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title=" 同步 "></a><span id="synchronization"> 同步 </span></h4><p>Java提供了多种方式供不同线程间通信，其中最基本的方法就是同步——使用监视器（monitor）实现。Java中的每个对象都关联了一个监视器，线程可以对监视器进行加锁（lock）和解锁（unlock）。同一时刻，某一监视器的锁只能被一个线程持有。此时，任何其他线程试图获取该锁时，都会导致线程阻塞，直到它能够获得监视器的锁。线程t可以对某一监视器多次加锁，每次解锁将只消除一次锁的效果。</p><p><code>synchronized</code>语句会计算对某一对象的引用，然后尝试对该对象的监视器进行加锁操作，如果加锁成功才会进行进一步的动作。在加锁动作完成后，<code>synchronized</code>语句的主题部分才被执行。执行正常结束或者异常结束都会自动地对监视器执行解锁操作。</p><p>当<code>synchronized</code>方法被调用时，它自动地执行加锁操作，它的主体部分在加锁操作成功完成后方可执行。如果该方法是个实例方法，则会对调用该方法的实例（也就是在执行该方法时，可以被认为是this的对象）的监视器进行加锁操作。如果是静态方法，则会对静态方法所在类的Class对象的监视器进行加锁操作。当被调用方法的主体执行完毕，不管是正常还是异常，会释放对应监视器的锁。</p><p>Java既不能避免，也不要求死锁条件检测。如果需要的化，那些会直接或间接地持有对多个对象锁的程序需要使用传统的技术来避免思索的发生，或者创造高级的、不会死锁的locking primitives。其他像对<code>volatile</code>变量的读写、使用<code>java.util.concurrent</code>包中的类等机制，提供了其他可选的同步方式。</p><h4 id="等待集和通知"><a href="#等待集和通知" class="headerlink" title=" 等待集和通知 "></a><span id="wsan"> 等待集和通知 </span></h4><p>除了监视器外，每个对象都关联了等待集（wait set）——线程组成的集合。对象被创建时，它的等待集为空。向等待集中添加或者删除线程的基本操作是原子性的（atomic）。仅可通过<code>Object.wait</code>、<code>Object.notify</code>和<code>Object.notifyAll</code>来操纵等待集。</p><p>等待集的操作也会被线程的终端状态、<code>Thread</code>类中处理中断的方法所影响。而且<code>Thread</code>类中的sleeping和joining其他线程的方法具有哪些来自等待和通知行为的性质。</p><blockquote><p>Additionally, the <code>Thread</code> class’s methods for sleeping and joining other threads have properties<br>derived from those of wait and notification actions.</p></blockquote><p>等待动作（wait action)发生在<code>wait()</code>方法或者其带时间的形式<code>wait(long millisecs)</code>和<code>wait(long millisecs, int nanosecs)</code>被调用时。当带时间的<code>wait</code>的参数全部为0时，与调用<code>wait()</code>的效果相同。</p><p>只有在未抛出<code>InterruptedException</code>异常时，才称线程从一个等待中正常返回。设线程t正在对象m上执行了<code>wait</code>方法，而且t在m上仍然有n个未解锁的lock动作，则会发生下面动作中的一种：</p><ul><li>如果n==0，即线程t不再拥有对象m的锁，抛出<code>IllegalMonitorStateException</code>异常</li><li>如果调用的是带时间的<code>wait</code>方法，而且参数<code>nanosecs</code>不再0-999999范围内，或者<code>millisecs</code>参数为负数，则抛出<code>IllegalArgumentException</code>异常</li><li>如果线程t被中断，则抛出<code>InterruptedException</code>，并设置t的中断状态为<code>false</code></li><li><p>如果不是上述情况中的任意一种，则：</p><ol><li>线程t被加入到对象m的等待集中，并且在m上执行n次解锁动作</li><li><p>线程t不会继续执行任何指令，直到它被从m的等待集中移除。移除的原因可能是下列任意一种：</p><ul><li>在m上执行了<code>notify</code>动作去移除t</li><li>在m上执行<code>notifyAll</code>移除m等待集中所有的线程</li><li>线程t发生了中断动作</li><li>如果是带时间的<code>wait</code>，将线程t从m的等待集中移除的内部动作发生在从<code>wait</code>操作发生至少<code>millisecs</code>毫秒+<code>nanosecs</code>纳秒之后</li><li>允许不同实现（implementation）去执行丰富的唤醒动作（spurious wake-ups），即从等待集中移除线程。因此，及时没有看到显式的指令去从等待集中移除线程，线程也有可能自动地从等待集中被移除。<blockquote><p> An internal action by the implementation. Implementations are permitted, although not encouraged, to perform “spurious wake-ups”, that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.</p></blockquote></li></ul><p>线程必须为导致其从等待集中被移除的事件确定一个顺序。这一顺序没有必要与其他的顺序一致，但是该线程却必须表现的好像那些事件是按那个顺序发生的。</p><p>例如，如果线程t在对象m的等待集中，之后t的中断和m的通知同时发生，这两个事件间必须有一个顺序。如果中断被认为是首先发生的，则t最终会从<code>wait</code>中返回，并抛出<code>InterruptedException</code>异常，而且m的等待集中的其他线程（如果存在的话）也必须接受这一通知。如果通知被认为是首先发生的，则t最终会正常地从<code>wait</code>中返回，中断等待。</p></li><li>线程t在对象m上执行n次锁动作</li><li>如果线程t因为中断而在步骤2中从m的等待集中被移除，则线程t的中断状态被设置为<code>false</code>，wait方法抛出<code>InterruptedException</code>异常</li></ol></li></ul><p>通知（notification）动作发生在<code>notify</code>、<code>notifyAll</code>方法被调用时。设t为在m对象上执行上述方法的线程，n为线程t在m上尚未被解锁动作matched的锁动作。下面的动作之一会发生：</p><ul><li>如果n==0，则抛出<code>IllegalMonitorStateException</code>异常，此时线程t已经不再拥有对象m的锁</li><li>如果n&gt;0，而且通知动作由<code>notify</code>方法引起，则如果m的等待集非空，则等待集中的一个成员u被选中，并从该等待集中被移除。这里并没有保证那个线程会被选中。此时的通知将会使线程u的wait动作恢复。线程u在恢复上的锁动作不能成功，直到线程t完全解锁m的监视器一段时间后。</li><li>如果n&gt;0，而且通知动作由<code>notifyAll</code>方法引起，则m等待集中所有的线程都被移除，并恢复执行。需要注意，在wait方法的恢复过程中，他们中只有一个能够获得m的监视器的锁。</li></ul><p>中断动作发生在调用<code>Thread.interrupt</code>方法和其他被定义用来调用它执行的方法，如<code>ThreadGroup.interrupt</code>方法。设t为调用u.interrupt方法的线程，t和u可以为同一个线程，将会导致线程u的中断状态设置为true。而且，如果存在对象m，它的等待集包含u，则u将被从m的等待集中移除。这将使得u恢复等待动作，在重新获得m的监视器锁后，wait动作将会抛出<code>InterruptedException</code>异常。</p><p>调用<code>Thread.isInterrupted</code>方法可以确定一个线程的中断状态，静态方法<code>Thread.interrupted</code>可能会被线程调用去观察并清除它自己的中断状态。</p><p>根据上面的规范描述，我们可以确定等待、通知、中断之间的交互关系：</p><ul><li>如果一个线程在等待的过程中同时被通知和中断，则会发生下述两种情况的一种：<ol><li>从wait中正常返回，中断被挂起，即调用<code>Thread.interrupted</code>方法会返回<code>true</code></li><li>从wait中返回，并抛出<code>InterruptedException</code>异常</li></ol></li><li>线程有有可能不重置它的中断状态，并且正常地从对wait的调用中返回</li><li>同样的，通知不能因为中断而丢失。假设s为对象m的等待集中线程的对象组成的集合，当其他的线程在m上执行<code>notify</code>时，会发生下述两种情况中的一种：<ol><li>s中至少有一个线程必须正常地从<code>wait</code>返回</li><li>s中所有的线程都必须退出<code>wait</code>，并抛出<code>InterruptedException</code>异常<br>注意：如果线程同时被中断和<code>notify</code>通知，则该线程从<code>wait</code>中返回并抛出<code>InterruptedException</code>异常，然后等待集合中的其他线程必须被通知。</li></ol></li></ul><h4 id="Sleep和Yield"><a href="#Sleep和Yield" class="headerlink" title=" Sleep和Yield "></a><span id="say"> Sleep和Yield </span></h4><p><code>Thread.sleep</code>导致当前正在执行的线程沉睡（临时地放弃执行）指定时间段，受制于系统计时器和调度器的精确度和准确度。线程不会失去对任何监视器的拥有权，执行的恢复将依赖于调度和处理器的可用性。需要注意的是，<code>Thread.sleep</code>和<code>Thread.yield</code>都没有任何同步语义。特别地，编译器没有必要在调用<code>Thread.sleep</code>或<code>Thread.yield</code>之前将缓存在寄存器中的写操作刷新到共享内存中，也没有必要在调用<code>Thread.sleep</code>或<code>Thread.yield</code>之后加载缓存在寄存器中的值。</p><p>例如，考虑如下的代码片段，并假设<code>this.done</code>是一个非volatile布尔域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="keyword">this</span>.done)</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>编译器可以只读取<code>this.done</code>变量一次，并且在每次循环时重用被缓存的值。这意味着循环可能永远不会停止，即使其他的线程改变了它的值。</p><h4 id="内存模型"><a href="#内存模型" class="headerlink" title=" 内存模型 "></a><span id="mm"> 内存模型 </span></h4><p>给定一个程序和该程序的一个执行迹，内存模型描述了该迹是否是程序的一次合法执行。Java中内存模型的工作原理是：测试迹中的每个read，并根据特定的规则检查能被该read观察到的write是否是合法的。内存模型描述了程序的可能性为。只要是程序所有的执行结果都可以通过内存模型预测，则无论Java的实现是怎样都是可以的。（这允许Java的实现者去做大量的代码转换，包括动作重排、移除不必要的同步）</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><a href="https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf" target="_blank" rel="noopener">The Java Language Specification, Java SE 8 Edition</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM支持多个线程的同时执行，它们独立地执行代码，操作保存在共享主存中的值和对象。多线程支持可以通过多个硬件处理器、单处理分时以及多处理器分时来实现。用户创建线程的唯一途径是实例化一个&lt;code&gt;Thread&lt;/code&gt;类的对象，并通过&lt;code&gt;start()&lt;/code&gt;方法来激活线程。如果未能正确的同步多线程，则它们的行为将可能是令人迷惑的，甚至是反直觉的。本章将介绍Java多线程程序的语义，它包含关于哪些变量是可见的（通过读被多个线程更新的共享内存）规则。&lt;br&gt;因为此规范类似于不同硬件体系结构的内存模型，语义也被称为是&lt;em&gt;Java编程语言内存模型&lt;/em&gt;。语义并没有规定一个多线程程序是如何执行的，而是描述了该程序被允许出现的行为。一个只会残生被允许行为的执行策略是一个可接受的执行策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://samson-bu.github.io/tags/java/"/>
    
      <category term="language specification" scheme="https://samson-bu.github.io/tags/language-specification/"/>
    
  </entry>
  
  <entry>
    <title>使用Enhancer笔记</title>
    <link href="https://samson-bu.github.io/2018/11/14/enhancer.html"/>
    <id>https://samson-bu.github.io/2018/11/14/enhancer.html</id>
    <published>2018-11-14T06:57:05.000Z</published>
    <updated>2018-11-26T02:10:44.167Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#mysql">MySQL中的常用命令</a></li></ul><h4 id="MySQL中的常用命令"><a href="#MySQL中的常用命令" class="headerlink" title=" MySQL中的常用命令 "></a><span id="mysql"> MySQL中的常用命令 </span></h4><ul><li>Ubuntu 18.04下安装MySQL<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure></li></ul><p>根据提示，创建root用户的密码。</p><ul><li><p>使用命令创建和删除数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> &lt;数据库名&gt;;</span><br><span class="line"><span class="keyword">USE</span> &lt;数据库名&gt;;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure></li><li><p>创建和删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">    属性名 数据类型 [完整约束条件],</span><br><span class="line">    属性名 数据类型 [完整约束条件],</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    属性名 数据类型 [完整约束条件]</span><br><span class="line">) <span class="keyword">default</span> <span class="keyword">charset</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>导入数据库备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 方式1 */</span><br><span class="line">mysql -uroot -pbxxing_5717 &lt;数据库名&gt; &lt; &lt;备份存储路径&gt;</span><br><span class="line">/* 方式2 */</span><br><span class="line"><span class="meta">mysql&gt;</span>source &lt;备份存储路径&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mysql&quot;&gt;MySQL中的常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的执行过程</title>
    <link href="https://samson-bu.github.io/2018/11/01/java-execution.html"/>
    <id>https://samson-bu.github.io/2018/11/01/java-execution.html</id>
    <published>2018-11-01T07:39:36.000Z</published>
    <updated>2018-11-30T06:35:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>《Java语言规范》详细描述了一个Java程序执行时的活动。本文将围绕着Java虚拟机以及程序所包含的类、接口和对象等的生命周期，介绍笔者对Java程序执行过程的理解。</p><p>执行过程从Java虚拟机（JVM）加载一个类并调用该类中的<code>main</code>方法开始。执行<code>main</code>方法时需要加载（loading）、链接（linking）和初始化（initialization）等步骤。接下来，本文将按照这个顺序，介绍每一步发生的活动。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#outline">概述</a></li><li><a href="#loading">加载</a></li><li><a href="#linking">链接</a></li><li><a href="#initialization">初始化</a></li><li><a href="#examples">一些示例</a></li><li><a href="#instantiation">实例化</a></li><li><a href="#finalization">终止化</a></li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><span id="outline">概述</span></h4><p>Java程序的执行过程从JVM调用程序中的<code>main</code>方法开始。JVM将传递给<code>main</code>方法一个字符串数组作为参数。字符串数组中的元素来自与启动JVM是的参数，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test hello world</span><br></pre></td></tr></table></figure></p><p>将启动JVM，调用<code>Test</code>类中的<code>main</code>方法，并将字符串数组<code>{ &quot;hello&quot;, &quot;world&quot; }</code>作为参数传递给<code>main</code>方法。</p><p>首次执行<code>main</code>方法是，JVM会发现<code>main</code>方法所在的类<code>Test</code>还没有加载——即JVM目前尚未包含该类的一个二进制表示（binary representation）。然后，JVM会尝试使用类加载器去寻找<code>Test</code>类的二进制表示（一般为Test.class文件）。如果加载过程出错，则会抛出异常。</p><p><code>Test</code>类加载以后，在<code>main</code>方法可以被调用之前，类<code>Test</code>必须首先被初始化。在初始化之前，<code>Test</code>必须先进行链接，这涉及验证（verification）、预处理（preparation）和resolution（可选的）。其中，验证确保加载的<code>Test</code>类的表示是格式良好的，并且据别一个恰当的符号表（symbol table）。而且验证也负责<code>Test</code>类中的代码是遵守Java变成语言和JVM的语义要求的。如果验证发现了错误，则会抛出异常。预处理涉及静态内存的分配和JVM内部需要使用的数据结构（例如方法表）的内存分配。resolution负责验证从<code>Test</code>类到其他类或接口的符号引用，这需要加载涉及的类或借口，并确保这些引用的争取性。</p><blockquote><p>这里的内容不太理解<br>The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early， even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of “static” linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an “a.out” file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the “a.out” file.)<br>An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the “laziest” form of resolution. In this case, if Test had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.<br>The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the “static” example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class Test or any of the further, recursively referenced, classes and interfaces. In a system that implemented the “laziest” resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.</p></blockquote><p>初始化包括以<code>textual order</code>（可能是指在文本中出main现的先后次序）执行任意类变量初始化器和类<code>Test</code>的静态初始化器。在<code>Test</code>类可被初始化之前，它的直接父类必须先被初始化（递归的）。如果类<code>Test</code>的直接父类为<code>Super</code>类，则<code>Test</code>被初始化之前，<code>Super</code>必须首先被初始化。初始化<code>Super</code>可能包含对该类的加载、验证和预处理。根据不同的JVM实现，可能还会包含对<code>Super</code>类中的符号引用的resolving。</p><p>初始化后，如果整个过程中没有任何异常抛出，<code>Test</code>类中的<code>main</code>方法将被调用（invoke）。<code>main</code>方法必须被声明为<code>public static void</code>，而且它的形参必须为字符串数组。如下形式的<code>main</code>方法声明都是可接受的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(Strin[] args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String... args)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><span id="loading">加载</span></h4><p>加载是指发现指定名称的类或者接口的二进制形式并从中构建一个Class对象来表示该类或接口的过程。类的名称可以是动态计算的，不过通常来说是由Java编译器计算得到的。类<code>ClassLoader</code>中的<code>defineClass</code>方法用来从.class文件中构建Class对象。</p><p>一个行为良好的类加载器需要具备以下性质：</p><ul><li>给定同样的类名，类加载器总能返回同样的类对象。</li><li>如果类加载器<code>L1</code>将类<code>C</code>的加载委托给另一个加载器<code>L2</code>，则对任意类型<code>T</code>（它可以为<code>C</code>的超类或者超接口，可以为<code>C</code>中某一属性[field]的类型，可以为<code>C</code>中方法或者构造方法的形参的类型，或者为<code>C</code>中方法的返回值类型）,<code>L1</code>和<code>L2</code>应该返回同样的Class对象。<br>一个不好的类加载器（malicious class loader）可能会违反上述的性质，但是它不会破获类型系统的安全性，因为JVM可以防止这种情况的发生。</li></ul><p>类的加载过程由<code>ClassLoader</code>类和它的子类实现，不同的子类会实现不同的加载策略。例如，一个类加载器可能会缓存（cache）类或者接口的二进制表示，或者根据预期的使用而提前获取它们，或者一次性的加载一组相关的类。例如，如果因为旧版本的二进制表示被类加载器缓存，而导致新编译的版本无法被找到，那么这些活动对正在运行的应用来说可能不是完全透明的。</p><blockquote><p>不太理解<br>These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader. It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.</p></blockquote><p>如果加载过程中发生错误，将会抛出<code>LinkageError</code>类的子类错误。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><span id="linking">链接</span></h4><p>链接是指拿到一个类或者接口的二进制形式，并将其合并到JVM的运行时状态中的过程，使得代码可以被执行。类或者接口在链接前，总是先被加载。链接一般涉及三个动作：验证，预处理和符号引用的解析（resolution of symbolic reference）。</p><p>《Java语言规范》允许链接活动发生时的实现灵活性，前提是遵循Java语言的语义、类或接口再被初始化之前已经进行了完全地验证和预处理、链接过程中检测到的错误已抛出。例如，一种实现（<em>指JVM实现？</em>）或许选择只有在使用时（lazy或late resolution）、或者在验证之后（static resolution）单独解析每个类或接口中的符号引用。这意味着，在某些实现中，符号引用的解析过程可能会持续到类或者接口初始化之后。因为链接过程中涉及对新数据结构的内存分配（<em>预处理阶段？</em>），因此它可能会抛出<code>OutOfMemoryError</code>错误。</p><ul><li>验证阶段，确保类或接口的二进制表示的结构是正确的。例如，它会检查指令的操作码是否正确，跳转指令将跳到某条指令的开始处而不是指令的中间部分，每个方法都有结构上正确的签名，每条指令都遵循JVM语言的类型约束。如果这个阶段发生错误，将会抛出<code>LinkageError</code>的子类<code>VerifyError</code>错误。</li><li>预处理阶段，涉及为每个类或接口的静态域（static field）分配内存空间，并初始化为默认值。这个过程不需要执行任何的源代码。静态域的显式初始化器的执行属于初始化阶段，而不是预处理阶段。</li><li>符号引用解析阶段，类或接口的二进制形式用其他类或接口的二进制名符号化地引用（reference）其它们或它们的域、方法和构造器。对域和方法来说，这些符号引用包含域和方法所在的类或接口的名称、域和方法的名称、以及对应的类型信息。符号引用必须经过解析才能够使用。解析可以检验符号引用的正确性，并将符号引用替换为直接引用（direct reference）——可以更高效地处理。如果在此阶段中发生错误，将会抛出<code>IncompatibleClassChangeError</code>类的子类错误。</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><span id="initialization">初始化</span></h4><p>类的初始化包括执行类的静态初始化器以及类中声明静态域的初始化器。接口的初始化包括执行（常亮）域的初始化器。类或接口T的初始化发生在以下任一事件发生时：</p><ul><li>T是类，并且T的一个<strong>对象被创建</strong>；</li><li>T中声明的<strong>静态方法被调用</strong>；</li><li>T中声明的<strong>静态域被赋值</strong>；</li><li>T中声明的静态域被使用，而且该域不是常量；</li><li>T是顶层类（top level class），T中lexically nested断言被执行。</li></ul><p>当一个类被初始化时，它的超类（<em>包括直接或间接？</em>）以及任意的超接口都将被先初始化（如果他们尚未被初始化）。接口的初始化不会引起它任何的超接口初始化。静态域的引用只会引起实际声明它的类或接口的初始化，尽管它可以通过子类或子接口或实现接口的类访问。（设类A声明了静态变量X，类B为类A的子类，则B.X不会引起类B的初始化，而会引声明了X的类A的初始化。）</p><p>调用<code>Class</code>类中或者<code>java.lang.reflect</code>包中的反射方法将会导致类或接口的初始化（<em>不太明白是导致那个类或接口的初始化，是Class类，还是调用Class类的类，还是要反射生成的类？极有可能是最后一种情况</em>）。类和接口在其他任何情况下都不会初始化。</p><p>初始化的意图是类或接口类型拥有一系列初始化器，可以将类或接口置于一个一致的状态，而且该状态也是其他类可观察到的首次状态。静态初始化器（<em>类的？</em>）和类变量的初始化器按照文本顺序（textual order，<em>声明的先后次序？</em>），而且不能（may not）引用这样的类变量——他们的声明出现在使用之后。这一限制是为了在编译时检测大多数循环或其他形式的初始化错误。</p><blockquote><p>不太理解<br>The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope (§8.3.3).</p></blockquote><p>初始化代码不受限制的事实允许构造如下的示例，在初始化表达式求值之前，类变量仍然是初始默认值时，它的值可被观测到。这个示例在实际中是很少见的。</p><blockquote><p>The fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice.</p></blockquote><p>Java支持多线程，所以类或接口的初始化需要考虑同步问题，避免多个线程同时对一个类或接口进行初始化造成不一致状态。而且，有可能发生对某一类或接口初始化的递归请求（尽管只会初始化一次）。例如，类A中的一个变量初始化器可能会调用类B中的某个方法，而这个方法又会反过来调用A中的某个方法。JVM通过下述初始化过程来来处理同步问题和递归请求。</p><p>假设已经完成对要初始化类的验证和预处理，类对象处于以下四种状态中的一种：</p><ul><li>类对象已经验证和预处理过，但是却尚未被初始化。</li><li>类对象正在被线程T初始化。</li><li>类对象已经被初始化完成，且是可用的。</li><li>类对象处于错误状态，可能是因为尝试初始化但未成功。</li></ul><p>为了解决接口初始化的同步问题，对每个接口或类C来说，存在一个初始化锁LC。则接口或类C的初始化详细过程如下：</p><ol><li>请求初始化锁LC，可能会导致当前线程等待，知道获得锁LC。</li><li>如果C的类对象正在被其他线程初始化，则释放LC，阻塞当前线程，直到收到C的类对象的初始化完成的通知。</li><li>如果C的类对象正在被当前进程初始化，表明当前的初始化请求是递归请求，则释放LC，过程正常结束。</li><li>如果C的类对象已经被初始化完成，表明不需要再进行初始化，则释放LC，过程正常结束。</li><li>如果C的类的对象处于错误状态，表明初始化是不可能完成的，则释放LC，抛出<code>NoClassDefFoundError</code>异常。</li><li>否则，表明C的类对象正在被当前线程初始化，将该信息记录在C的类对象中，释放LC。然后初始化C中为常量的静态域。</li><li>如果C是是一个类，而且C的超类尚未被初始化，则设SC为C的超类，SI1, SI2, …, SIn是C的所有超接口且至少声明了一个默认方法。超接口的顺序通过递归枚举C直接实现的接口的超接口层次结构确定（从左到右）。对任意一个C直接实现的接口I，递归枚举将先递归地枚举I的超接口（从左到右），然后才是接口I。对[SC, SI1, SI2, …, SIn]中的任意S，递归地执行初始化过程的全部步骤，如果必要的话，需要首先对S进行验证和预处理。如果S的初始化过程意外的终止了，并且抛出了异常，则请求初始化锁LC，标记C的类对象为错误状态，通知所有等待的进程，释放LC，初始化过程异常结束，将S初始化过程中产生的异常抛出。</li><li>接下来，通过查询定义的类装载器，确定是否为C启动断言。</li><li>接下来，对类来说，执行它的类变量初始化器和类的静态初始化器；对接口来说，执行它的域初始化器。（in textual order）</li><li>如果初始化器全部正常完成，则请求LC，标记C的类对象为完成初始化，通知所有等待的线程，释放LC，过程正常结束。</li><li>否则，初始化器肯定是异常终止，并且会抛出异常E。如果E不是<code>Error</code>或其任意子类，则将E作为参数创建类<code>ExceptionInInitializerError</code>的对象，并在接下来的步骤中用其代替E。如果在创建<code>ExceptionInInitializerError</code>对象的时候发生了内存溢出，则用<code>OutOfMemoryError</code>的对象替代E。</li><li>请求LC，标记C的类对象处于错误状态，通知所有等待进程，释放LC，初始化过程异常结束，抛出异常E。</li></ol><h4 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a><span id="examples">一些实例</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Super "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"One "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Two "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        One o = <span class="keyword">null</span>;</span><br><span class="line">        Two t = <span class="keyword">new</span> Two();</span><br><span class="line">        System.out.println((Object)o == (Object)t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为 Super Two false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> taxi = <span class="number">1729</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Sub "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sub.taxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为 1729</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, ii = Test.out(<span class="string">"ii"</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">J</span> <span class="keyword">extends</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = Test.out(<span class="string">"j"</span>, <span class="number">3</span>), jj = Test.out(<span class="string">"jj"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">K</span> <span class="keyword">extends</span> <span class="title">J</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = Test.out(<span class="string">"k"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(J.i);</span><br><span class="line">        System.out.println(K.j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">out</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"="</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* (ii = 2)不会出现，因为J.i是常量，不会引起接口I的初始化</span></span><br><span class="line"><span class="comment">* 1</span></span><br><span class="line"><span class="comment">* j = 3</span></span><br><span class="line"><span class="comment">* jj = 4</span></span><br><span class="line"><span class="comment">* 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="实例化"><a href="#实例化" class="headerlink" title=" 实例化 "></a><span id="instantiation"> 实例化 </span></h4><p>类的实例可以通过类实例创建表达式显式地创建。以下几种情况会隐式地创建类的实例：</p><ul><li>加载包含<code>String</code>文字（literal）的类或接口时，可能会创建新的<code>String</code>类的对象来表示这个文字。如果该字符串文字以前已经出现过（interned），这一过程也可能不会发生。</li><li>执行可能会引起自动包装转型（boxing conversion）的操作，可能会创建包装类的对象。</li><li>执行不是常量表达式一部分的字符串连接操作<code>+</code>会创建一个String对象来表示结果。而且字符串连接操作可能会创建primitive type值的包装类的对象。</li><li>方法引用表达式或者lambda表达式的求值或许会要求创建实现了功能接口的类的对象。</li></ul><p>当一个新的类实例被创建时，JVM会为它的实例变量、以及其超类的实例变量（包括隐藏的实例变量）分配内存空间。如果可用空间不足，则会抛出<code>OutOfMemoryError</code>，实例化过程异常终止。否则（可用空间足够），所有的实例变量被初始化为它们的默认值。在指向新创建对象的引用作为结果返回时，所用的构造器将根据以下步骤去初始化该对象：</p><ol><li>将构造器的参数赋值给新创建参数变量。</li><li>如果调用的构造器以对本类中的其他构造器的调用开始，（using this(….)），则递归地去处理调用的构造器。如果调用的构造器异常退出，则当前构造器也异常退出，并且抛出同样的异常，如果正常退出，则调到步骤5.</li><li>没有调用本类中的其他构造器，如果是非Object类的构造器，则它会首先（显式地或隐式地）调用超类的构造器，（using super(…)）。递归地对父类构造器进行求值，如果过程中发生异常，则抛出。否则跳到步骤4。</li><li>执行实例初始化器和实例变量初始化器，将实例变量初始化器的值赋值给对应的实例变量，按照它们在源代码出现的顺序。如果执行初始化器导致了异常的发生，则不在执行后续的初始化器，然后过程异常退出。否则，调到步骤5.</li><li>执行构造器中的其他语句，如果执行过程发生异常，则整个构造过程以同样的异常原因退出。否则，构造过程正常结束。</li></ol><p>考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point() &#123; x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> color = <span class="number">0xFF00FF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ColoredPoint cp = <span class="keyword">new</span> ColoredPoint(); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(cp.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1处代码创建了<code>ColoredPoint</code>类的一个对象<code>cp</code>，具体过程如下：</p><ol><li>首先，为对象<code>cp</code>分配内存空间，用来存放<code>x</code>,<code>y</code>和<code>color</code>。这些变量被初始化为默认值，此处为0.</li><li>接下来，类<code>ColoredPoint</code>中不含参数的构造器被调用。因为<code>ColoredPoint</code>中并未显式地声明这样一个无参的构造器，所以编译器自动的为其添加构造器：<code>ColoredPoint() { super(); }</code>。然后这个构造器会调用<code>Point</code>类中的无参构造器。因为<code>Point(){}</code>并未在开始处调用其他的构造器，所以编译器隐式地为其添加对其超类的构造器的调用：<code>Point(){ super(); x = 1; y = 1; }</code>。所以<code>Object</code>类的无参构造器将被调用。因为<code>Object</code>没有父类，所以递归到此为止。</li><li>接下来，<code>Object</code>类中的实例初始化器和实例变量初始化器被调用。之后，<code>Object</code>类中无参构造器中的剩余部分将执行。因为<code>Object</code>类中为声明无参构造器，所以编译器将添加：<code>Object() { }</code>。</li><li><code>Point</code>类的实例变量初始化器执行。因为<code>x</code>和<code>y</code>都没有给定初始化表达式，不会做任何动作。之后<code>Point() { super(); x = 1; y = 1; }</code>中的剩余部分执行，<code>x</code>和<code>y</code>被赋值为1。</li><li><code>Colored</code>类中的实例变量初始化器执行，<code>color</code>被赋值为0xFF00FF。之后执行<code>ColoredPoint() { super(); }</code>中的剩余部分，结束实例化过程。</li></ol><p>再考虑下面的这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    Super() &#123; printThree(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"three"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> three = (<span class="keyword">int</span>)Math.PI; <span class="comment">// That is, 3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123; System.out.println(three); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();  <span class="comment">// 1</span></span><br><span class="line">        t.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>1处的代码会创建一个<code>Test</code>类对象<code>t</code>，具体过程如下：</p><ol><li>首先为<code>t</code>分配内存空间，用来存储其变量（此处为<code>three</code>），并将它们初始化为默认值0。</li><li>接下来，会调用无参构造器<code>Test()</code>，因为<code>Test</code>类中未声明该构造器，Java编译器会默认添加如下构造器<code>Test() { super(); }</code>。接下来<code>Test</code>的直接父类<code>Super</code>的无参构造器被调用，因为<code>Super()</code>中未包含对其他构造器的调用，Java编译器会自动添加对其父类的默认构造器的调用，即对<code>Object</code>类中无参构造器的调用。</li><li><code>Object</code>类中的实例初始化器和实例变量初始化器会执行，对<code>t</code>的内存空间中的对应数据进行初始化。之后<code>Object</code>类中的无参构造器执行完毕，开始执行<code>Super</code>中的实例初始化器和实例变量初始化器，对<code>t</code>的内存空间中的对应数据进行初始化，之后执行<code>printThreee</code>方法。应为该方法被重载，所以调用的是<code>Test</code>类中的<code>printThree</code>方法，而此时<code>Test</code>类中的实例初始化器和实例变量初始化器尚未执行，所以<code>three</code>的值依旧为0。</li><li>之后，执行<code>Test</code>类的实例初始化器和实例变量初始化器，将<code>three</code>赋值为3，之后执行<code>Test</code>类中无参构造器中的剩余部分，完成实例化过程。</li></ol><h4 id="终止化"><a href="#终止化" class="headerlink" title="终止化"></a><span id="finalization">终止化</span></h4><p><code>Object</code>类中声明了一个名为<code>finalize</code>的protected方法，可被其他类重载。可被对象调用的<code>finalize</code>的某一特定实现被称为该对象的<em>终止化器</em>（finalizer）。在垃圾回收器（GC）回收某一对象的空间时，JVM会调用该对象的终止化器。</p><p>终止化器的作用是为了释放那些不能够被自动存储管理释放的资源。在这种情况下（不能自动回收的情况？），简单地回收对象使用的内存并不能保证它拥有的资源都被回收。</p><p>Java语言中除了指明某一对象的终止化器的调用发生在该对象拥有的内存被重用之前，但并未说明会多快（how soon)地调用终止化器。而且Java语言也并未指定由哪个线程来调用一个对象的终止化器。Java没有强加<code>finalize</code>方法的调用顺序，他们可以以任何顺序，甚至是并发地执行。</p><p><em>待补充其他内容</em></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><a href="https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf" target="_blank" rel="noopener">The Java Language Specification, Java SE 8 Edition</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java语言规范》详细描述了一个Java程序执行时的活动。本文将围绕着Java虚拟机以及程序所包含的类、接口和对象等的生命周期，介绍笔者对Java程序执行过程的理解。&lt;/p&gt;
&lt;p&gt;执行过程从Java虚拟机（JVM）加载一个类并调用该类中的&lt;code&gt;main&lt;/code&gt;方法开始。执行&lt;code&gt;main&lt;/code&gt;方法时需要加载（loading）、链接（linking）和初始化（initialization）等步骤。接下来，本文将按照这个顺序，介绍每一步发生的活动。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://samson-bu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://samson-bu.github.io/tags/java/"/>
    
      <category term="language specification" scheme="https://samson-bu.github.io/tags/language-specification/"/>
    
  </entry>
  
  <entry>
    <title>Java实现的单例模式及其在多线程情景下的常见问题</title>
    <link href="https://samson-bu.github.io/2018/10/30/java-singleton.html"/>
    <id>https://samson-bu.github.io/2018/10/30/java-singleton.html</id>
    <published>2018-10-30T06:39:27.000Z</published>
    <updated>2018-11-30T05:48:34.071Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式(Singleton Pattern)是系统设计中常用的一种设计模式，用于限定某一类有且仅有单个实例，并提供对该实例的全局访问控制。其<strong>本质</strong>是确保某一个类只有一个对象被创建。</p><p>维基百科中对单例模式的描述为：</p><blockquote><p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.</p></blockquote><p>本文将讲述我对单例模式在单线程和多线程情境下应用的理解。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#single">单线程情景</a></li><li><a href="#multiple">多线程情景</a></li><li><a href="#refs">参考文献</a></li></ul><h4 id="单线程情景下的单例模式"><a href="#单线程情景下的单例模式" class="headerlink" title="单线程情景下的单例模式"></a><span id="single">单线程情景下的单例模式</span></h4><ul><li>饿汉模式，使用静态私有变量保存该类的唯一实例，在类加载时创建：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 声明时即创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 使用私有构造方法限制对象的创建</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉模式，将实例的创建延迟到第一次调用该实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>; <span class="comment">// 声明时不创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 使用私有构造方法限制对象的创建</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供对唯一实例的全局访问方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 唯一对象的创建延迟到第一次调用时</span></span><br><span class="line">        <span class="keyword">if</span> (instance == ull) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instnace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析。<ol><li>饿汉模式在类加载时就开始创建对象，而不管是否有其他人在使用，比较浪费资源，但是可以确保对象只被创建一次。因为类只加载一次。</li><li>懒汉模式在有其他人使用时才创建对象，这在单线程情景下是正常的。但在多线程情景下却是非线程安全的。接下来将分析不安全原因并讨论解决方法。</li></ol></li></ul><h4 id="多线程情景下的单例模式"><a href="#多线程情景下的单例模式" class="headerlink" title="多线程情景下的单例模式"></a><span id="multiple">多线程情景下的单例模式</span></h4><ul><li>在懒汉模式中使用<code>synchronized</code>关键字修饰<code>getInstance</code>方法:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>对<code>getInstance</code>方法加锁，及时有多个线程同时调用该方法，同步锁也能保证某一时刻只能有一个线程在执行此方法。使用加锁的方法来保证单例模式的线程安全效率非常的低，因为每次调用该方法就必须先加锁，而实际上只有第一次创建<code>instance</code>对象时需要加锁，即1处的语句只需要执行一次。</p><p>可能有些朋友就有疑问了，既然只需要保证1处的代码执行一次，何不考虑只对1处的代码进行同步，像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码其实起不到保证线程安全的目的，考虑下面的例子：假设有两个线程a和b，1)a和b同时执行到<code>if</code>判断语句，此时因为<code>instance</code>尚未创建，所以a和b同时进入到2处。2)<code>synchronized</code>只能保证a和b是按顺序执行1处的语句的，而不能保证1处的代码只执行一次。这里的问题显然和单线程情景下的懒汉模式是一样的。</p><p>因此，如果要保证1处的代码只执行一次，需要再次对<code>instance</code>进行判空检查：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检查</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>乍看起来，这种方法是可以正常工作的，不过仍然存在着出错的可能。在Java中，创建对象需要经历在堆上分配内存、初始化和返回对象在堆上的引用等步骤。但是Java在做这些工作的时候可能不会按照固定的顺序，例如有可能会先分配内存，之后就返回对象在堆上的引用，之后才初始化。这种无序化可能会使上述的双重检查仍然存在安全问题。考虑如下情景：线程a和b同时执行到2处，1)线程a首先进入同步块中，此时<code>instance</code>的值为<code>null</code>，所以会执行1处的代码，然后离开同步块。2)假如分配内存之后，直接就返回对象在堆上的引用（尚未初始化），此时线程b进入同步块，以为<code>instance</code>的值已经不为<code>null</code>，<code>getInstance</code>方法直接返回<code>instance</code>。注意，此时instance可能尚未初始化完成，线程b使用instance将会报错。</p><p>Java1.5之后，可以使用关键字<code>volatile</code>来修饰变量，<code>volatile</code>会禁止JVM指令重排，所以可以解决上面的问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检查</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>使用内部类实现懒汉模式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部静态类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，类<code>Singleton</code>不包含任何的静态属性，直到调用<code>getInstance</code>方法时，会加载内部静态类<code>SingletonHolder</code>，并初始化内部静态类中的静态属性。因为是静态属性，所以对象只会创建一次。而且对象创建被延迟到首次使用时。</p><h4 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h4><ol><li>单例模式与序列化</li></ol><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><span id="refs">参考文献</span></h4><ol><li><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">java designe patterns</a></li><li><a href="https://blog.csdn.net/a_lonely_dancer/article/details/52445402" target="_blank" rel="noopener">你所不知道的单例模式和多线程并发在单例模式中的影响</a></li><li><a href="https://www.cnblogs.com/prayers/p/7468540.html" target="_blank" rel="noopener">JAVA_多线程_单例模式</a></li><li><a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">单例模式与双重检测</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式(Singleton Pattern)是系统设计中常用的一种设计模式，用于限定某一类有且仅有单个实例，并提供对该实例的全局访问控制。其&lt;strong&gt;本质&lt;/strong&gt;是确保某一个类只有一个对象被创建。&lt;/p&gt;
&lt;p&gt;维基百科中对单例模式的描述为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将讲述我对单例模式在单线程和多线程情境下应用的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://samson-bu.github.io/tags/java/"/>
    
      <category term="设计模式" scheme="https://samson-bu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Markdown的基础用法</title>
    <link href="https://samson-bu.github.io/2018/10/26/markdown.html"/>
    <id>https://samson-bu.github.io/2018/10/26/markdown.html</id>
    <published>2018-10-26T08:32:02.000Z</published>
    <updated>2018-11-30T05:48:44.401Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录维护博客期间使用到的Markdown语法。</p><p>持续更新中…</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#syntax">常用语法</a></li></ul><h4 id="常用语法"><a href="#常用语法" class="headerlink" title=" 常用语法 "></a><span id="syntax"> 常用语法 </span></h4><ul><li>列表<ul><li>无序列表，使用符号<code>*/+/-</code>中的任意一种</li><li>有序列表，使用符号<code>数字.</code></li></ul></li></ul><div class="tip"><br>    列表符号和列表内容之间必须存在一个空格，有序列表和无序列表可以相互嵌套。<br></div><ul><li><p>超链接</p><ul><li><p>页内链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 先定义一个锚（id），&lt;span id=&quot;target&quot;&gt; Target &lt;/span&gt;</span><br><span class="line">2. 使用[xxxx](target)，将建立xxxx到Target的页内链接</span><br></pre></td></tr></table></figure></li><li><p>网页链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 内联方式 [xxxx](url)</span><br><span class="line">2. 引用方式 [google][1]     [1]: http://google.com/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字体</p><ul><li>加粗 <code>**text**</code></li><li>斜体 <code>*text*</code></li><li>自定义字体大小 <code>&lt;font size=4&gt;text&lt;/font&gt;</code> </li><li>字体大小标签 <code>&lt;small&gt;</code>/<code>&lt;big&gt;</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录维护博客期间使用到的Markdown语法。&lt;/p&gt;
&lt;p&gt;持续更新中…&lt;/p&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="https://samson-bu.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo框架 + Apollo主题 + Github Pages搭建静态博客</title>
    <link href="https://samson-bu.github.io/2018/10/26/blog-by-hexo.html"/>
    <id>https://samson-bu.github.io/2018/10/26/blog-by-hexo.html</id>
    <published>2018-10-26T08:09:49.000Z</published>
    <updated>2018-11-30T05:49:24.850Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍我搭建个人博客的步骤和用到的工具。我选择<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>作为博客框架，使用Markdown解析文章，选择风格简洁的<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">Apollo</a>作为博客主题。最后，我将生成的静态页面部署到Github中，借助Github Pages显示。</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#hexo">Hexo框架</a> </li><li><a href="#apollo">Apollo主题</a></li><li><a href="#pages">Github Pages</a></li></ul><h4 id="Hexo框架"><a href="#Hexo框架" class="headerlink" title="Hexo框架"></a><span id="hexo">Hexo框架</span></h4><p>  Hexo框架需要以来以下程序:</p><ul><li><a href="https://nodejs.org" target="_blank" rel="noopener">node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">git</a></li></ul><p>如果您的电脑上已具备上述程序，则可以通过以下方式快速安装Hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>如果您的电脑上尚未安装上述程序，可参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文章</a>中介绍的方法进行安装。</p><p>安装完成后，可以通过<code>hexo --version</code>检查Hexo是否安装正确以及当前的版本。</p><p>Hexo安装成功后，通过下列命令可以创建一个站点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog // 将创建一个名为blog的文件夹，并进行适当的初始化</span><br></pre></td></tr></table></figure></p><p>blog文件夹中的文件结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><ul><li><code>_config.yml</code>包含网站的配置信息；</li><li><code>package.json</code>和<code>node_modules</code>包含项目的依赖信息以及依赖模块；</li><li><code>scaffolds</code>为模板文件夹，新建文章时，Hexo将根据scaffolds中的模板来建立文件；</li><li><code>source</code>存放用户资源，除<code>_posts</code>文件夹之外，开头命名为<code>_</code>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略，Markdown和HTML文件会被解析并放到<code>public</code>文件夹（可以在<code>_config.yml</code>中进行配置），而其他文件会被拷贝过去；</li><li><code>themes</code>主题文件夹，用来存放网站使用的主题文件，Hexo根据这些主题生成静态页面。</li></ul><p>新建站点后，使用<code>new</code>命令可以新建一片文章：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p><p>文章编辑完成后，使用<code>generate</code>命令，Hexo可以生成静态页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p><p>持续更新中…<br>预览生成的静态页面，可以使用过<code>server</code>命令启动服务器，用浏览器访问<code>logcalhost:4000</code>进行页面预览：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><h4 id="Apollo主题"><a href="#Apollo主题" class="headerlink" title="Apollo主题"></a><span id="apollo">Apollo主题</span></h4><p>这里我选择<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">Apollo</a>作为博客的主题，主要原因是风格比较简约。<br>首先进入到要使用该主题的站点中，然后安装依赖模块，最后下载Apollo主题到<code>themes</code>文件中并在<code>_config.yml</code>中启用对该主题的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd blog_folder</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive  // 安装依赖模块</span><br><span class="line">git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo // 下载主题</span><br><span class="line">修改_config.yml中的配置，将theme项的值修改为apollo：</span><br><span class="line">theme: apollo</span><br><span class="line"></span><br><span class="line"># 在归档页面显示所有文章</span><br><span class="line"># 需要上面安装的 hexo-generator-archive 插件支持</span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 0</span><br><span class="line">  yearly: false</span><br><span class="line">  monthly: false</span><br><span class="line">  daily: false</span><br></pre></td></tr></table></figure><p>之后重新生成静态页面，启动服务器进行预览，可以看到主题更新后的效果。如果不能正常预览，请自行百度解决。</p><h4 id="将博客部署到Github-Pages"><a href="#将博客部署到Github-Pages" class="headerlink" title="将博客部署到Github Pages"></a><span id="pages">将博客部署到Github Pages</span></h4><p><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>是本来是用于展示托管在Github上的项目。不过，因为它提供了免费且稳定的空间，也可以用来搭建个人博客。而且Github允许用户创建一个特殊的仓库<code>username.github.io</code> 用来存储个人主页，而且提供域名解析服务，使用浏览器访问<code>username.github.io</code>即可访问个人主页。</p><div class="tip"><br>  个人主页必须在master分支下，而且如果项目名称为user_name.github.io这种格式，则所显示的静态页面信息也必须在master分之下的主目录中才可以。<br></div><blockquote><p>If your site is a User or Organization Page that has a repository named <code>username.github.io</code> or <code>orgname.github.io</code> , you cannot publish your site’s source files from different locations. User and Organization Pages that have this type of repository name are only published from the <code>master</code> branch.</p></blockquote><ul><li>在Github中创建名为<code>username.github.io</code>的项目；</li><li><p>修改站点中的配置<code>_config.yml</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/***  # 项目的实际地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>使用<code>hexo deploy</code>命令即可将项目部署到Github中，部署过程中可能需要根据提示输入Github的账户用户名和密码等信息。</p></li></ul><div class="tip"><br>  使用git将站点部署到Github需要提前安装一个扩展： <code>npm install hexo-deployer-git --save</code><br></div><p>至此，搭建博客的配置过程基本完成。之后再写文章只需要使用<code>new</code>命令新建文章，编写完成后使用<code>deploy</code>命令部署即可。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>待补充</strong></p><ul><li>Github Keys</li><li>绑定独立域名</li><li>使用图床</li><li>添加插件</li><li>添加404</li><li>添加支付宝捐赠按钮</li></ul><p><strong>参考</strong></p><ol><li><a href="https://www.cnblogs.com/dushao/p/5999593.html" target="_blank" rel="noopener">杜少博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍我搭建个人博客的步骤和用到的工具。我选择&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;作为博客框架，使用Markdown解析文章，选择风格简洁的&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apollo&lt;/a&gt;作为博客主题。最后，我将生成的静态页面部署到Github中，借助Github Pages显示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://samson-bu.github.io/tags/hexo/"/>
    
      <category term="过程记录" scheme="https://samson-bu.github.io/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
