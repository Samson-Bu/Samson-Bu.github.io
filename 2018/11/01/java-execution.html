<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java的执行过程 · Samson's Blog</title><meta name="description" content="Java的执行过程 - Samson Bu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://samson-bu.github.io/atom.xml" title="Samson's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/samson-bu/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java的执行过程</h1><div class="post-info">Nov 1, 2018</div><div class="post-content"><p>《Java语言规范》详细描述了一个Java程序执行时的活动。本文将围绕着Java虚拟机以及程序所包含的类、接口和对象等的生命周期，介绍笔者对Java程序执行过程的理解。</p>
<p>执行过程从Java虚拟机（JVM）加载一个类并调用该类中的<code>main</code>方法开始。执行<code>main</code>方法时需要加载（loading）、链接（linking）和初始化（initialization）等步骤。接下来，本文将按照这个顺序，介绍每一步发生的活动。</p>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#outline">概述</a></li>
<li><a href="#loading">加载</a></li>
<li><a href="#linking">链接</a></li>
<li><a href="#initialization">初始化</a></li>
<li><a href="#examples">一些示例</a></li>
<li><a href="#instantiation">实例化</a></li>
<li><a href="#finalization">终止化</a></li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><span id="outline">概述</span></h4><p>Java程序的执行过程从JVM调用程序中的<code>main</code>方法开始。JVM将传递给<code>main</code>方法一个字符串数组作为参数。字符串数组中的元素来自与启动JVM是的参数，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test hello world</span><br></pre></td></tr></table></figure></p>
<p>将启动JVM，调用<code>Test</code>类中的<code>main</code>方法，并将字符串数组<code>{ &quot;hello&quot;, &quot;world&quot; }</code>作为参数传递给<code>main</code>方法。</p>
<p>首次执行<code>main</code>方法是，JVM会发现<code>main</code>方法所在的类<code>Test</code>还没有加载——即JVM目前尚未包含该类的一个二进制表示（binary representation）。然后，JVM会尝试使用类加载器去寻找<code>Test</code>类的二进制表示（一般为Test.class文件）。如果加载过程出错，则会抛出异常。</p>
<p><code>Test</code>类加载以后，在<code>main</code>方法可以被调用之前，类<code>Test</code>必须首先被初始化。在初始化之前，<code>Test</code>必须先进行链接，这涉及验证（verification）、预处理（preparation）和resolution（可选的）。其中，验证确保加载的<code>Test</code>类的表示是格式良好的，并且据别一个恰当的符号表（symbol table）。而且验证也负责<code>Test</code>类中的代码是遵守Java变成语言和JVM的语义要求的。如果验证发现了错误，则会抛出异常。预处理涉及静态内存的分配和JVM内部需要使用的数据结构（例如方法表）的内存分配。resolution负责验证从<code>Test</code>类到其他类或接口的符号引用，这需要加载涉及的类或借口，并确保这些引用的争取性。</p>
<blockquote>
<p>这里的内容不太理解<br>The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early， even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of “static” linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an “a.out” file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the “a.out” file.)<br>An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the “laziest” form of resolution. In this case, if Test had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.<br>The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the “static” example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class Test or any of the further, recursively referenced, classes and interfaces. In a system that implemented the “laziest” resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.</p>
</blockquote>
<p>初始化包括以<code>textual order</code>（可能是指在文本中出main现的先后次序）执行任意类变量初始化器和类<code>Test</code>的静态初始化器。在<code>Test</code>类可被初始化之前，它的直接父类必须先被初始化（递归的）。如果类<code>Test</code>的直接父类为<code>Super</code>类，则<code>Test</code>被初始化之前，<code>Super</code>必须首先被初始化。初始化<code>Super</code>可能包含对该类的加载、验证和预处理。根据不同的JVM实现，可能还会包含对<code>Super</code>类中的符号引用的resolving。</p>
<p>初始化后，如果整个过程中没有任何异常抛出，<code>Test</code>类中的<code>main</code>方法将被调用（invoke）。<code>main</code>方法必须被声明为<code>public static void</code>，而且它的形参必须为字符串数组。如下形式的<code>main</code>方法声明都是可接受的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(Strin[] args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String... args)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><span id="loading">加载</span></h4><p>加载是指发现指定名称的类或者接口的二进制形式并从中构建一个Class对象来表示该类或接口的过程。类的名称可以是动态计算的，不过通常来说是由Java编译器计算得到的。类<code>ClassLoader</code>中的<code>defineClass</code>方法用来从.class文件中构建Class对象。</p>
<p>一个行为良好的类加载器需要具备以下性质：</p>
<ul>
<li>给定同样的类名，类加载器总能返回同样的类对象。</li>
<li>如果类加载器<code>L1</code>将类<code>C</code>的加载委托给另一个加载器<code>L2</code>，则对任意类型<code>T</code>（它可以为<code>C</code>的超类或者超接口，可以为<code>C</code>中某一属性[field]的类型，可以为<code>C</code>中方法或者构造方法的形参的类型，或者为<code>C</code>中方法的返回值类型）,<code>L1</code>和<code>L2</code>应该返回同样的Class对象。<br>一个不好的类加载器（malicious class loader）可能会违反上述的性质，但是它不会破获类型系统的安全性，因为JVM可以防止这种情况的发生。</li>
</ul>
<p>类的加载过程由<code>ClassLoader</code>类和它的子类实现，不同的子类会实现不同的加载策略。例如，一个类加载器可能会缓存（cache）类或者接口的二进制表示，或者根据预期的使用而提前获取它们，或者一次性的加载一组相关的类。例如，如果因为旧版本的二进制表示被类加载器缓存，而导致新编译的版本无法被找到，那么这些活动对正在运行的应用来说可能不是完全透明的。</p>
<blockquote>
<p>不太理解<br>These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader. It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.</p>
</blockquote>
<p>如果加载过程中发生错误，将会抛出<code>LinkageError</code>类的子类错误。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a><span id="linking">链接</span></h4><p>链接是指拿到一个类或者接口的二进制形式，并将其合并到JVM的运行时状态中的过程，使得代码可以被执行。类或者接口在链接前，总是先被加载。链接一般涉及三个动作：验证，预处理和符号引用的解析（resolution of symbolic reference）。</p>
<p>《Java语言规范》允许链接活动发生时的实现灵活性，前提是遵循Java语言的语义、类或接口再被初始化之前已经进行了完全地验证和预处理、链接过程中检测到的错误已抛出。例如，一种实现（<em>指JVM实现？</em>）或许选择只有在使用时（lazy或late resolution）、或者在验证之后（static resolution）单独解析每个类或接口中的符号引用。这意味着，在某些实现中，符号引用的解析过程可能会持续到类或者接口初始化之后。因为链接过程中涉及对新数据结构的内存分配（<em>预处理阶段？</em>），因此它可能会抛出<code>OutOfMemoryError</code>错误。</p>
<ul>
<li>验证阶段，确保类或接口的二进制表示的结构是正确的。例如，它会检查指令的操作码是否正确，跳转指令将跳到某条指令的开始处而不是指令的中间部分，每个方法都有结构上正确的签名，每条指令都遵循JVM语言的类型约束。如果这个阶段发生错误，将会抛出<code>LinkageError</code>的子类<code>VerifyError</code>错误。</li>
<li>预处理阶段，涉及为每个类或接口的静态域（static field）分配内存空间，并初始化为默认值。这个过程不需要执行任何的源代码。静态域的显式初始化器的执行属于初始化阶段，而不是预处理阶段。</li>
<li>符号引用解析阶段，类或接口的二进制形式用其他类或接口的二进制名符号化地引用（reference）其它们或它们的域、方法和构造器。对域和方法来说，这些符号引用包含域和方法所在的类或接口的名称、域和方法的名称、以及对应的类型信息。符号引用必须经过解析才能够使用。解析可以检验符号引用的正确性，并将符号引用替换为直接引用（direct reference）——可以更高效地处理。如果在此阶段中发生错误，将会抛出<code>IncompatibleClassChangeError</code>类的子类错误。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><span id="initialization">初始化</span></h4><p>类的初始化包括执行类的静态初始化器以及类中声明静态域的初始化器。接口的初始化包括执行（常亮）域的初始化器。类或接口T的初始化发生在以下任一事件发生时：</p>
<ul>
<li>T是类，并且T的一个<strong>对象被创建</strong>；</li>
<li>T中声明的<strong>静态方法被调用</strong>；</li>
<li>T中声明的<strong>静态域被赋值</strong>；</li>
<li>T中声明的静态域被使用，而且该域不是常量；</li>
<li>T是顶层类（top level class），T中lexically nested断言被执行。</li>
</ul>
<p>当一个类被初始化时，它的超类（<em>包括直接或间接？</em>）以及任意的超接口都将被先初始化（如果他们尚未被初始化）。接口的初始化不会引起它任何的超接口初始化。静态域的引用只会引起实际声明它的类或接口的初始化，尽管它可以通过子类或子接口或实现接口的类访问。（设类A声明了静态变量X，类B为类A的子类，则B.X不会引起类B的初始化，而会引声明了X的类A的初始化。）</p>
<p>调用<code>Class</code>类中或者<code>java.lang.reflect</code>包中的反射方法将会导致类或接口的初始化（<em>不太明白是导致那个类或接口的初始化，是Class类，还是调用Class类的类，还是要反射生成的类？极有可能是最后一种情况</em>）。类和接口在其他任何情况下都不会初始化。</p>
<p>初始化的意图是类或接口类型拥有一系列初始化器，可以将类或接口置于一个一致的状态，而且该状态也是其他类可观察到的首次状态。静态初始化器（<em>类的？</em>）和类变量的初始化器按照文本顺序（textual order，<em>声明的先后次序？</em>），而且不能（may not）引用这样的类变量——他们的声明出现在使用之后。这一限制是为了在编译时检测大多数循环或其他形式的初始化错误。</p>
<blockquote>
<p>不太理解<br>The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope (§8.3.3).</p>
</blockquote>
<p>初始化代码不受限制的事实允许构造如下的示例，在初始化表达式求值之前，类变量仍然是初始默认值时，它的值可被观测到。这个示例在实际中是很少见的。</p>
<blockquote>
<p>The fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice.</p>
</blockquote>
<p>Java支持多线程，所以类或接口的初始化需要考虑同步问题，避免多个线程同时对一个类或接口进行初始化造成不一致状态。而且，有可能发生对某一类或接口初始化的递归请求（尽管只会初始化一次）。例如，类A中的一个变量初始化器可能会调用类B中的某个方法，而这个方法又会反过来调用A中的某个方法。JVM通过下述初始化过程来来处理同步问题和递归请求。</p>
<p>假设已经完成对要初始化类的验证和预处理，类对象处于以下四种状态中的一种：</p>
<ul>
<li>类对象已经验证和预处理过，但是却尚未被初始化。</li>
<li>类对象正在被线程T初始化。</li>
<li>类对象已经被初始化完成，且是可用的。</li>
<li>类对象处于错误状态，可能是因为尝试初始化但未成功。</li>
</ul>
<p>为了解决接口初始化的同步问题，对每个接口或类C来说，存在一个初始化锁LC。则接口或类C的初始化详细过程如下：</p>
<ol>
<li>请求初始化锁LC，可能会导致当前线程等待，知道获得锁LC。</li>
<li>如果C的类对象正在被其他线程初始化，则释放LC，阻塞当前线程，直到收到C的类对象的初始化完成的通知。</li>
<li>如果C的类对象正在被当前进程初始化，表明当前的初始化请求是递归请求，则释放LC，过程正常结束。</li>
<li>如果C的类对象已经被初始化完成，表明不需要再进行初始化，则释放LC，过程正常结束。</li>
<li>如果C的类的对象处于错误状态，表明初始化是不可能完成的，则释放LC，抛出<code>NoClassDefFoundError</code>异常。</li>
<li>否则，表明C的类对象正在被当前线程初始化，将该信息记录在C的类对象中，释放LC。然后初始化C中为常量的静态域。</li>
<li>如果C是是一个类，而且C的超类尚未被初始化，则设SC为C的超类，SI1, SI2, …, SIn是C的所有超接口且至少声明了一个默认方法。超接口的顺序通过递归枚举C直接实现的接口的超接口层次结构确定（从左到右）。对任意一个C直接实现的接口I，递归枚举将先递归地枚举I的超接口（从左到右），然后才是接口I。对[SC, SI1, SI2, …, SIn]中的任意S，递归地执行初始化过程的全部步骤，如果必要的话，需要首先对S进行验证和预处理。如果S的初始化过程意外的终止了，并且抛出了异常，则请求初始化锁LC，标记C的类对象为错误状态，通知所有等待的进程，释放LC，初始化过程异常结束，将S初始化过程中产生的异常抛出。</li>
<li>接下来，通过查询定义的类装载器，确定是否为C启动断言。</li>
<li>接下来，对类来说，执行它的类变量初始化器和类的静态初始化器；对接口来说，执行它的域初始化器。（in textual order）</li>
<li>如果初始化器全部正常完成，则请求LC，标记C的类对象为完成初始化，通知所有等待的线程，释放LC，过程正常结束。</li>
<li>否则，初始化器肯定是异常终止，并且会抛出异常E。如果E不是<code>Error</code>或其任意子类，则将E作为参数创建类<code>ExceptionInInitializerError</code>的对象，并在接下来的步骤中用其代替E。如果在创建<code>ExceptionInInitializerError</code>对象的时候发生了内存溢出，则用<code>OutOfMemoryError</code>的对象替代E。</li>
<li>请求LC，标记C的类对象处于错误状态，通知所有等待进程，释放LC，初始化过程异常结束，抛出异常E。</li>
</ol>
<h4 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a><span id="examples">一些实例</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Super "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"One "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Two "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        One o = <span class="keyword">null</span>;</span><br><span class="line">        Two t = <span class="keyword">new</span> Two();</span><br><span class="line">        System.out.println((Object)o == (Object)t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为 Super Two false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> taxi = <span class="number">1729</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.print(<span class="string">"Sub "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sub.taxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为 1729</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, ii = Test.out(<span class="string">"ii"</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">J</span> <span class="keyword">extends</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = Test.out(<span class="string">"j"</span>, <span class="number">3</span>), jj = Test.out(<span class="string">"jj"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">K</span> <span class="keyword">extends</span> <span class="title">J</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = Test.out(<span class="string">"k"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(J.i);</span><br><span class="line">        System.out.println(K.j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">out</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"="</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* (ii = 2)不会出现，因为J.i是常量，不会引起接口I的初始化</span></span><br><span class="line"><span class="comment">* 1</span></span><br><span class="line"><span class="comment">* j = 3</span></span><br><span class="line"><span class="comment">* jj = 4</span></span><br><span class="line"><span class="comment">* 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="实例化"><a href="#实例化" class="headerlink" title=" 实例化 "></a><span id="instantiation"> 实例化 </span></h4><p>类的实例可以通过类实例创建表达式显式地创建。以下几种情况会隐式地创建类的实例：</p>
<ul>
<li>加载包含<code>String</code>文字（literal）的类或接口时，可能会创建新的<code>String</code>类的对象来表示这个文字。如果该字符串文字以前已经出现过（interned），这一过程也可能不会发生。</li>
<li>执行可能会引起自动包装转型（boxing conversion）的操作，可能会创建包装类的对象。</li>
<li>执行不是常量表达式一部分的字符串连接操作<code>+</code>会创建一个String对象来表示结果。而且字符串连接操作可能会创建primitive type值的包装类的对象。</li>
<li>方法引用表达式或者lambda表达式的求值或许会要求创建实现了功能接口的类的对象。</li>
</ul>
<p>当一个新的类实例被创建时，JVM会为它的实例变量、以及其超类的实例变量（包括隐藏的实例变量）分配内存空间。如果可用空间不足，则会抛出<code>OutOfMemoryError</code>，实例化过程异常终止。否则（可用空间足够），所有的实例变量被初始化为它们的默认值。在指向新创建对象的引用作为结果返回时，所用的构造器将根据以下步骤去初始化该对象：</p>
<ol>
<li>将构造器的参数赋值给新创建参数变量。</li>
<li>如果调用的构造器以对本类中的其他构造器的调用开始，（using this(….)），则递归地去处理调用的构造器。如果调用的构造器异常退出，则当前构造器也异常退出，并且抛出同样的异常，如果正常退出，则调到步骤5.</li>
<li>没有调用本类中的其他构造器，如果是非Object类的构造器，则它会首先（显式地或隐式地）调用超类的构造器，（using super(…)）。递归地对父类构造器进行求值，如果过程中发生异常，则抛出。否则跳到步骤4。</li>
<li>执行实例初始化器和实例变量初始化器，将实例变量初始化器的值赋值给对应的实例变量，按照它们在源代码出现的顺序。如果执行初始化器导致了异常的发生，则不在执行后续的初始化器，然后过程异常退出。否则，调到步骤5.</li>
<li>执行构造器中的其他语句，如果执行过程发生异常，则整个构造过程以同样的异常原因退出。否则，构造过程正常结束。</li>
</ol>
<p>考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point() &#123; x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> color = <span class="number">0xFF00FF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ColoredPoint cp = <span class="keyword">new</span> ColoredPoint(); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(cp.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1处代码创建了<code>ColoredPoint</code>类的一个对象<code>cp</code>，具体过程如下：</p>
<ol>
<li>首先，为对象<code>cp</code>分配内存空间，用来存放<code>x</code>,<code>y</code>和<code>color</code>。这些变量被初始化为默认值，此处为0.</li>
<li>接下来，类<code>ColoredPoint</code>中不含参数的构造器被调用。因为<code>ColoredPoint</code>中并未显式地声明这样一个无参的构造器，所以编译器自动的为其添加构造器：<code>ColoredPoint() { super(); }</code>。然后这个构造器会调用<code>Point</code>类中的无参构造器。因为<code>Point(){}</code>并未在开始处调用其他的构造器，所以编译器隐式地为其添加对其超类的构造器的调用：<code>Point(){ super(); x = 1; y = 1; }</code>。所以<code>Object</code>类的无参构造器将被调用。因为<code>Object</code>没有父类，所以递归到此为止。</li>
<li>接下来，<code>Object</code>类中的实例初始化器和实例变量初始化器被调用。之后，<code>Object</code>类中无参构造器中的剩余部分将执行。因为<code>Object</code>类中为声明无参构造器，所以编译器将添加：<code>Object() { }</code>。</li>
<li><code>Point</code>类的实例变量初始化器执行。因为<code>x</code>和<code>y</code>都没有给定初始化表达式，不会做任何动作。之后<code>Point() { super(); x = 1; y = 1; }</code>中的剩余部分执行，<code>x</code>和<code>y</code>被赋值为1。</li>
<li><code>Colored</code>类中的实例变量初始化器执行，<code>color</code>被赋值为0xFF00FF。之后执行<code>ColoredPoint() { super(); }</code>中的剩余部分，结束实例化过程。</li>
</ol>
<p>再考虑下面的这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    Super() &#123; printThree(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"three"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> three = (<span class="keyword">int</span>)Math.PI; <span class="comment">// That is, 3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123; System.out.println(three); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();  <span class="comment">// 1</span></span><br><span class="line">        t.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>1处的代码会创建一个<code>Test</code>类对象<code>t</code>，具体过程如下：</p>
<ol>
<li>首先为<code>t</code>分配内存空间，用来存储其变量（此处为<code>three</code>），并将它们初始化为默认值0。</li>
<li>接下来，会调用无参构造器<code>Test()</code>，因为<code>Test</code>类中未声明该构造器，Java编译器会默认添加如下构造器<code>Test() { super(); }</code>。接下来<code>Test</code>的直接父类<code>Super</code>的无参构造器被调用，因为<code>Super()</code>中未包含对其他构造器的调用，Java编译器会自动添加对其父类的默认构造器的调用，即对<code>Object</code>类中无参构造器的调用。</li>
<li><code>Object</code>类中的实例初始化器和实例变量初始化器会执行，对<code>t</code>的内存空间中的对应数据进行初始化。之后<code>Object</code>类中的无参构造器执行完毕，开始执行<code>Super</code>中的实例初始化器和实例变量初始化器，对<code>t</code>的内存空间中的对应数据进行初始化，之后执行<code>printThreee</code>方法。应为该方法被重载，所以调用的是<code>Test</code>类中的<code>printThree</code>方法，而此时<code>Test</code>类中的实例初始化器和实例变量初始化器尚未执行，所以<code>three</code>的值依旧为0。</li>
<li>之后，执行<code>Test</code>类的实例初始化器和实例变量初始化器，将<code>three</code>赋值为3，之后执行<code>Test</code>类中无参构造器中的剩余部分，完成实例化过程。</li>
</ol>
<h4 id="终止化"><a href="#终止化" class="headerlink" title="终止化"></a><span id="finalization">终止化</span></h4><p><code>Object</code>类中声明了一个名为<code>finalize</code>的protected方法，可被其他类重载。可被对象调用的<code>finalize</code>的某一特定实现被称为该对象的<em>终止化器</em>（finalizer）。在垃圾回收器（GC）回收某一对象的空间时，JVM会调用该对象的终止化器。</p>
<p>终止化器的作用是为了释放那些不能够被自动存储管理释放的资源。在这种情况下（不能自动回收的情况？），简单地回收对象使用的内存并不能保证它拥有的资源都被回收。</p>
<p>Java语言中除了指明某一对象的终止化器的调用发生在该对象拥有的内存被重用之前，但并未说明会多快（how soon)地调用终止化器。而且Java语言也并未指定由哪个线程来调用一个对象的终止化器。Java没有强加<code>finalize</code>方法的调用顺序，他们可以以任何顺序，甚至是并发地执行。</p>
<p><em>待补充其他内容</em></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf" target="_blank" rel="noopener">The Java Language Specification, Java SE 8 Edition</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/14/enhancer.html" class="prev">PREV</a><a href="/2018/10/30/java-singleton.html" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://samson-bu.github.io">Samson Bu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>